
#include <bits/stdc++.h>

// 1. 함수의 정의
// 2. 베이스 컨디션
// 3. 재귀식

// 1. 정의 2^N 크기의 배열에 r,c 위치를 방문하기 까지 걸리는 횟수를 구한다.
int Solve(int n, int r, int c)
{
    // 2. 베이스 컨디션
    if (n == 0)
    {
        return 0;
    }
    // 3. 재귀식

    // 4등분 하고 방문
    // 4등분을 할려면 절반씩 가로 세로 나눠주면되니까
    // 한 변의 길이의 절반을 구하면 그 값이 기준이 될 수 있음.
    // 여기서 한 변의 길이는 2^N이므로 이 절반은 2^N-1

    // 점점 작게 쪼개면서 가야하니까 n-1씩 시켜서 들어가는건 쉽게 생각할수있었는데
    // r,c에 half를 빼주는거는 절차적으로 생각하면 안되고, 쪼갠 영역 하나 하나 안에서의 새로운 위치 라고 생각해야할듯.
    // 4x4 에서 3,0을 찾는다, 좌하단 3번슬롯에 해당함 한변의길이는 4고 4등분하기위해 구한 하프의 길이는 2
    // 하프를 기준으로 짤랐고 잘라 들어간 3번 슬롯안에서의 해당 위치는 1,0이 되는거니까 half 길이를 빼준다.
    // 큰 그림으로 보는게 아니라 쪼개는 순간 다 개별로 바라보는 시각
    // 그 개별의 결과를 합쳐서 총 결과를 구하기 때문에 분할정복..

    // 어떤 특정한 것을 생각하지말고 기준을 잡아야함.
    // 게임 개발할때 개체별로 쪼개서 역할을 나누듯이..
    // 하나 하나를 개별로 봐야하고 그 하나 하나의 처리에서 작용할 기준을 찾아야한다.

    int half = 1 << (n - 1);
    if (r < half && c < half)
    {
        // 좌상단(0번슬롯)
        return Solve(n - 1, r, c);
    }

    if (r < half && c >= half)
    {
        // 우상단(1번슬롯)
        return half * half + Solve(n - 1, r, c - half);
    }

    if (r >= half && c < half)
    {
        // 좌하단(3번슬롯)
        return 2 * half * half + Solve(n - 1, r - half, c);
    }

    // r >= half && c >= half일때 우하단4번슬롯 가야하지만
    // 리턴이 무조건 존재해야 하기 때문에 별도로 if문을 두지않음.

    // 우하단
    return 3 * half * half + Solve(n - 1, r - half, c - half);
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, r, c;
    std::cin >> n >> r >> c;

    std::cout << Solve(n, r, c);

    return 0;
}